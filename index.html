<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>City finding game</title>

<!-- Performance hints for Wikipedia -->
<link rel="preconnect" href="https://en.wikipedia.org" crossorigin>
<link rel="preconnect" href="https://upload.wikimedia.org" crossorigin>

<!-- Leaflet -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""
/>
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<!-- Papa Parse -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<style>
  :root {
    --bg: #0b0c0f;
    --panel: #111317;
    --muted: #a9b0bd;
    --text: #e9eef6;
    --accent: #6aa0ff;
    --good: #22c55e;
    --mid: #f59e0b;
    --border: #1f2430;
  }
  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial;}

  /* Top bar: brand (left), absolute-centered title (city/distance/summary), action button on right */
  .topbar {
    position: fixed; z-index: 1000; top: 0; left: 0; right: 0;
    background: #0e1117; border-bottom: 1px solid var(--border);
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 12px; box-shadow: 0 2px 12px rgba(0,0,0,0.35);
  }
  .brand, .current-city {
    font-size: 22px; font-weight: 800; letter-spacing: .2px;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .brand { width: 180px; }
  .current-city {
    position: absolute; left: 50%; transform: translateX(-50%);
    text-align: center; max-width: calc(100vw - 360px);
  }
  .current-city .cty { color: #fff; }
  .current-city .sub { color: var(--muted); font-weight: 600; margin-left: 8px; }
  .topbar-right { width: 180px; display:flex; justify-content:flex-end; }

  .btn { appearance: none; border: none; cursor: pointer; padding: 10px 12px; border-radius: 12px;
    background: #1a2233; color: var(--text); transition: transform .02s ease, opacity .2s ease, background .2s ease;
    font-weight: 600; letter-spacing: .2px; }
  .btn:hover { background: #1d2740; } .btn:active { transform: translateY(1px); }
  .btn.accent { background: var(--accent); color: #081021; } .btn.accent:hover { opacity: .95; }

  /* Layout below the topbar */
  .app {
    display: grid;
    grid-template-columns: 380px 1fr;
    grid-template-rows: calc(100vh - 56px);
    margin-top: 56px;
  }
  .sidebar { background: var(--panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; }
  .section { padding: 16px 18px; border-bottom: 1px solid var(--border); }
  h1 { font-size: 18px; margin: 0 0 8px; letter-spacing: .2px; }
  .muted { color: var(--muted); font-size: 13px; }

  #map { height: calc(100vh - 56px); width: 100%; }

  .scorebox { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
  .scorecard { background: #0d0f13; border: 1px solid var(--border); border-radius: 12px; padding: 10px; text-align: center; }
  .scorecard .big { font-size: 22px; font-weight: 700; }

  /* Wikipedia panel in sidebar (visible only during feedback mode) */
  .wiki-side { display: none; gap: 10px; }
  .wiki-side.open { display: grid; }
  .wiki-title {
    font-weight: 800; margin: 0; font-size: 22px; letter-spacing: .2px;
  }
  .wiki-image { width: 100%; border-radius: 10px; display: none; }
  .wiki-extract { font-size: 13px; color: var(--muted); line-height: 1.45; max-height: 28vh; overflow: auto; }
  .wiki-actions { display:flex; gap:10px; }
  .wiki-actions a { text-decoration: none; color: var(--text); font-weight: 600; }

  .controls label { display: block; font-size: 13px; margin-bottom: 6px; color: var(--muted); }
  .controls .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .controls input[type="number"] {
    width: 100%; padding: 10px 12px; background: #0d0f13; border: 1px solid var(--border);
    border-radius: 10px; color: #e9eef6;
  }
  .btnbar { display: flex; gap: 8px; flex-wrap: wrap; }

  @media (max-width: 1000px) {
    .app { grid-template-columns: 1fr; grid-template-rows: auto 70vh; }
    #map { height: calc(70vh); }
    .current-city { font-size: 18px; max-width: calc(100vw - 240px); }
    .brand, .topbar-right { width: 120px; }
  }
</style>
</head>
<body>

<!-- Top bar -->
<div class="topbar">
  <div class="brand">Find the city</div>
  <div class="current-city" id="currentCityTop"></div>
  <div class="topbar-right">
    <button id="confirmBtn" class="btn accent" title="Submit your current pin">Confirm</button>
  </div>
</div>

<div class="app">
  <aside class="sidebar">
    <!-- CONTROLS (top in normal mode; hidden during feedback) -->
    <div id="controlsSection" class="section controls">
      <h1>Controls</h1>
      <label>Difficulty (population threshold)</label>
      <div class="radio-group" id="difficultyGroup" style="display:grid;gap:6px;margin-top:8px;">
        <label class="radio-item" style="display:flex;align-items:center;gap:8px;">
          <input type="radio" name="difficulty" value="1000000">
          <span>≥ 1,000,000</span>
        </label>
        <label class="radio-item" style="display:flex;align-items:center;gap:8px;">
          <input type="radio" name="difficulty" value="100000" checked>
          <span>≥ 100,000</span>
        </label>
        <label class="radio-item" style="display:flex;align-items:center;gap:8px;">
          <input type="radio" name="difficulty" value="10000">
          <span>≥ 10,000</span>
        </label>
        <label class="radio-item" style="display:flex;align-items:center;gap:8px;">
          <input type="radio" name="difficulty" value="custom" id="diffCustom">
          <span>Custom ≥</span>
          <input id="customMinPop" type="number" min="1" step="1000" value="10000" style="max-width:120px;">
        </label>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Number per round</label>
          <input id="numPerRound" type="number" min="1" max="200" step="1" value="10" />
        </div>
      </div>

      <div class="btnbar" style="margin-top:10px;">
        <button id="startBtn" class="btn accent">Start new round</button>
        <button id="resetBtn" class="btn">Clear map</button>
      </div>
    </div>

    <!-- WIKIPEDIA PANEL (appears only during feedback) -->
    <div id="wikiSection" class="section">
      <div id="wikiSide" class="wiki-side">
        <div class="wiki-title" id="wikiTitle">Wikipedia</div>
        <img id="wikiImg" class="wiki-image" alt="Place image" loading="lazy"/>
        <div class="wiki-extract" id="wikiExtract"></div>
        <div class="wiki-actions" id="wikiActions" style="display:none;">
          <a id="wikiLink" target="_blank" rel="noopener">Open on Wikipedia</a>
        </div>
      </div>
    </div>

    <!-- ROUND STATUS (below controls/panel) -->
    <div id="statusSection" class="section">
      <h1>Round status</h1>
      <div class="scorebox" style="margin-bottom:10px;">
        <div class="scorecard"><div class="muted">Guessed</div><div id="guessedCount" class="big">0</div></div>
        <div class="scorecard"><div class="muted">Remaining</div><div id="remainingCount" class="big">0</div></div>
      </div>
      <!-- Empty area kept intentionally; results use top-center title instead. -->
      <div id="summary" style="display:none;"></div>
    </div>
  </aside>

  <div id="map"></div>
</div>

<script>
/* ========= Distance (km) ========= */
function haversineKm(lat1,lon1,lat2,lon2){
  const R=6371, toRad=d=>d*Math.PI/180;
  const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
  const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(a));
}
function fmtKm(km){ if(km<1) return `${(km*1000).toFixed(0)} m`; if(km<100) return `${km.toFixed(1)} km`; return `${Math.round(km)} km`; }

/* ========= Map ========= */
const map=L.map('map',{minZoom:1.5,worldCopyJump:true,attributionControl:true}).setView([20,0],2);
const baseNoLabels = L.tileLayer('https://basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png',{attribution:'&copy; OpenStreetMap &copy; CARTO'}).addTo(map);
const labelsOverlay = L.tileLayer('https://basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png',{attribution:''});
map.setMaxBounds([[-85,-200],[85,200]]);

const WORLD_VIEW = { center: [20,0], zoom: 2 };

/* ========= State ========= */
let adminMap = {}; // "CC.Admin1Code" -> Subdivision name
let allCities=[];   // [{name, lat, lon, pop, sub, country}]
let roundCities=[]; let currentIndex=-1;
let guesses=[];

let provisional = null; // {lat, lon, marker}
let actionMode = 'confirm'; // 'confirm' | 'next' | 'results' | 'restart'

const currentCityTopEl=document.getElementById('currentCityTop');
const confirmBtn=document.getElementById('confirmBtn');
const controlsSection = document.getElementById('controlsSection');
const wikiSide = document.getElementById('wikiSide');

const guessedCountEl=document.getElementById('guessedCount');
const remainingCountEl=document.getElementById('remainingCount');

/* Feedback layers (only for current city) */
let feedbackLayers = [];

/* Results layers (entire round) */
let resultLayers = [];

/* ========= Wikipedia cache (per session) ========= */
const wikiCache = new Map(); // key: cityKey, value: {title, extract, imgSrc, pageUrl}
function cityKey(c){ return `${c.name}||${c.sub||''}||${c.country||''}`; }

/* ========= Wikipedia: coordinate-first selection ========= */

const WIKI_TIMEOUT_MS = 5000;

function abortableFetch(url, opts = {}, timeoutMs = WIKI_TIMEOUT_MS){
  const controller = new AbortController();
  const id = setTimeout(()=>controller.abort(), timeoutMs);
  return fetch(url, {...opts, signal: controller.signal}).finally(()=>clearTimeout(id));
}

async function mwApi(params){
  const qs = new URLSearchParams({...params, format:'json', origin:'*'});
  const url = `https://en.wikipedia.org/w/api.php?${qs.toString()}`;
  const r = await abortableFetch(url);
  if(!r.ok) throw new Error('Wikipedia API error');
  return r.json();
}

function typeScore(desc=''){
  const d = (desc||'').toLowerCase();
  if(d.includes('capital city')) return 50;
  if(d.includes('prefecture-level city')) return 46;
  if(d.includes('city')) return 45;
  if(d.includes('town')) return 40;
  if(d.includes('municipality')) return 35;
  if(d.includes('commune')) return 32;
  if(d.includes('borough')) return 28;
  if(d.includes('village')) return 20;
  if(d.includes('settlement')) return 18;
  if(d.includes('metropolitan area') || d.includes('district') || d.includes('province') || d.includes('regency') || d.includes('county') || d.includes('agreement') || d.includes('estate') || d.includes('university')) return -25;
  return 0;
}

function nameHintScore(city, title){
  const n = (city.name||'').toLowerCase();
  const t = (title||'').toLowerCase();
  if(t === n) return 12;
  if(t.startsWith(n+',') || t.startsWith(n+' ')) return 10;
  if(t.includes(n)) return 4;
  return 0;
}

function distScoreKm(cityLat, cityLon, pageLat, pageLon){
  if(pageLat==null || pageLon==null) return 0;
  const d = haversineKm(cityLat, cityLon, pageLat, pageLon);
  // up to +30 for 0–30 km, then 0
  return Math.max(0, 30 - Math.min(30, d));
}

async function chooseBestWikiByCoords(city){
  const lat = city.lat, lon = city.lon;
  const radii = [5000, 10000, 20000, 30000]; // meters
  let titles = [];

  for(const r of radii){
    try{
      const geo = await mwApi({
        action:'query', list:'geosearch', gscoord:`${lat}|${lon}`,
        gsradius:r, gslimit:20, gsnamespace:0
      });
      titles = (geo.query?.geosearch || []).map(g=>g.title);
      if(titles.length) break; // got candidates
    }catch(e){ /* continue to next radius */ }
  }

  if(!titles.length){
    // No nearby pages -> try a single name-based search as fallback
    const fallbacks = [];
    if(city.sub && city.country) fallbacks.push(`${city.name}, ${city.sub}, ${city.country}`);
    if(city.sub) fallbacks.push(`${city.name}, ${city.sub}`);
    if(city.country) fallbacks.push(`${city.name}, ${city.country}`);
    fallbacks.push(city.name);

    try{
      const s = await mwApi({ action:'query', list:'search', srsearch: `intitle:"${fallbacks[0]}"`, srlimit:10, srprop:'' });
      titles = (s.query?.search || []).map(x=>x.title);
    }catch(e){}
  }

  if(!titles.length){
    return { title: city.name, extract: 'No summary found on Wikipedia.', imgSrc: null, pageUrl: null };
  }

  // Batch fetch coordinates, description, images, URL
  let pages = [];
  try{
    const info = await mwApi({
      action:'query',
      prop:'coordinates|description|pageimages|info',
      piprop:'thumbnail|original', pithumbsize:640,
      inprop:'url',
      titles: Array.from(new Set(titles)).slice(0,40).join('|')
    });
    pages = Object.values(info.query?.pages || {});
  }catch(e){}

  // Score candidates
  let best = null, bestScore = -Infinity;
  for(const p of pages){
    const title = p.title || '';
    const desc  = p.description || '';
    const c = Array.isArray(p.coordinates) ? p.coordinates[0] : null;
    const pageLat = c?.lat, pageLon = c?.lon;

    const score = distScoreKm(lat, lon, pageLat, pageLon)
                + typeScore(desc)
                + nameHintScore(city, title);

    if(score > bestScore){ bestScore = score; best = p; }
  }

  if(!best){
    return { title: city.name, extract: 'No summary found on Wikipedia.', imgSrc: null, pageUrl: null };
  }

  // Fetch REST summary for the winner (clean extract + image + proper URL)
  try{
    const slug = encodeURIComponent(best.title.replace(/\s+/g,'_'));
    const r = await abortableFetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${slug}?redirect=true`);
    if(r.ok){
      const d = await r.json();
      return {
        title: d.title || best.title,
        extract: d.extract || best.description || 'No summary available.',
        imgSrc: d.originalimage?.source || d.thumbnail?.source || null,
        pageUrl: d.content_urls?.desktop?.page || best.fullurl || null
      };
    }
  }catch(e){ /* fall back below */ }

  return {
    title: best.title,
    extract: best.description || 'No summary available.',
    imgSrc: (best.original && best.original.source) || (best.thumbnail && best.thumbnail.source) || null,
    pageUrl: best.fullurl || null
  };
}

async function showWikipediaPanel(city){
  // Show panel + "Loading…" immediately
  const wikiTitle = document.getElementById('wikiTitle');
  const wikiExtract = document.getElementById('wikiExtract');
  const wikiLink = document.getElementById('wikiLink');
  const wikiActions = document.getElementById('wikiActions');
  const wikiImg = document.getElementById('wikiImg');

  wikiTitle.textContent = `${city.name}${city.sub ? ' — ' + city.sub : ''}`;
  wikiExtract.textContent = 'Loading…';
  wikiImg.style.display='none'; wikiImg.removeAttribute('src');
  wikiActions.style.display='none';

  const key = cityKey(city);
  if(wikiCache.has(key)){
    const info = wikiCache.get(key);
    wikiTitle.textContent = info.title || `${city.name}${city.sub ? ' — ' + city.sub : ''}`;
    wikiExtract.textContent = info.extract || 'No summary available.';
    if(info.imgSrc){ wikiImg.src = info.imgSrc; wikiImg.style.display='block'; } else { wikiImg.style.display='none'; wikiImg.removeAttribute('src'); }
    if(info.pageUrl){ wikiLink.href = info.pageUrl; wikiActions.style.display='flex'; } else { wikiActions.style.display='none'; }
    return;
  }

  // Fetch + cache
  try{
    const info = await chooseBestWikiByCoords(city);
    wikiCache.set(key, info);
    wikiTitle.textContent = info.title || `${city.name}${city.sub ? ' — ' + city.sub : ''}`;
    wikiExtract.textContent = info.extract || 'No summary available.';
    if(info.imgSrc){ wikiImg.src = info.imgSrc; wikiImg.style.display='block'; } else { wikiImg.style.display='none'; wikiImg.removeAttribute('src'); }
    if(info.pageUrl){ wikiLink.href = info.pageUrl; wikiActions.style.display='flex'; } else { wikiActions.style.display='none'; }
  }catch(e){
    wikiTitle.textContent = `${city.name}${city.sub ? ' — ' + city.sub : ''}`;
    wikiExtract.textContent = 'No summary found on Wikipedia.';
    wikiImg.style.display='none'; wikiImg.removeAttribute('src');
    wikiActions.style.display='none';
  }
}

/* ========= UI helpers ========= */
function cityLabel(c){ return c.sub ? `${c.name} — ${c.sub}` : c.name; }
function setTopCity(cityObj){ currentCityTopEl.innerHTML = cityObj ? `<span class="cty">${cityObj.name}</span>${cityObj.sub?` <span class="sub">— ${cityObj.sub}</span>`:''}` : ''; }
function setTopDistance(km){ currentCityTopEl.innerHTML = `<span class="cty">${fmtKm(km)} away</span>`; }
function setTopRoundSummary(){ currentCityTopEl.innerHTML = `<span class="cty">Round summary</span>`; }

function updateScoreBox(){
  guessedCountEl.textContent=guesses.length;
  remainingCountEl.textContent=Math.max(0, roundCities.length - guesses.length);
}

/* ========= Sidebar visibility ========= */
function showFeedbackUI(){
  controlsSection.style.display = 'none';
  wikiSide.classList.add('open');
}
function hideFeedbackUI(){
  controlsSection.style.display = '';
  wikiSide.classList.remove('open');
}

/* ========= Map helpers ========= */
function resetMapView(){
  if(map.hasLayer(labelsOverlay)) map.removeLayer(labelsOverlay);
  clearFeedbackLayers();
  if(provisional && provisional.marker){ map.removeLayer(provisional.marker); }
  provisional = null;
  map.setView(WORLD_VIEW.center, WORLD_VIEW.zoom, {animate:true});
}
function clearFeedbackLayers(){
  feedbackLayers.forEach(l => map.removeLayer(l));
  feedbackLayers = [];
}
function fitToAllGuesses(){
  const pts=[];
  guesses.forEach(g=>{
    pts.push([g.trueLat,g.trueLon],[g.guessLat,g.guessLon]);
  });
  if(pts.length){
    const bounds = L.latLngBounds(pts);
    map.fitBounds(bounds.pad(0.2));
  }else{
    resetMapView();
  }
}
function clearResultLayers(){
  resultLayers.forEach(l => map.removeLayer(l));
  resultLayers = [];
}
function drawResultsLayers(){
  clearResultLayers();
  guesses.forEach(g=>{
    const guessMarker=L.circleMarker([g.guessLat,g.guessLon],{
      radius:5, weight:2, color:'#6aa0ff', fillColor:'#6aa0ff', fillOpacity:0.35
    }).bindTooltip(`Your guess — ${fmtKm(g.distKm)}`,{direction:'top'});
    const trueMarker=L.circleMarker([g.trueLat,g.trueLon],{
      radius:5, weight:2, color:'#22c55e', fillColor:'#22c55e', fillOpacity:0.5
    }).bindTooltip(`${cityLabel(g.city)} — true`,{direction:'top'});
    const line=L.polyline([[g.guessLat,g.guessLon],[g.trueLat,g.trueLon]],{
      weight:2, color:'#f59e0b', opacity:.9, dashArray:'4,4'
    });
    guessMarker.addTo(map); trueMarker.addTo(map); line.addTo(map);
    resultLayers.push(guessMarker,trueMarker,line);
  });
}

/* ========= Provisional pin handling ========= */
map.on('click',(e)=>{
  if(currentIndex<0 || currentIndex>=roundCities.length) return;
  if(actionMode!=='confirm') return; // no pin during feedback/results
  const lat=e.latlng.lat, lon=e.latlng.lng;
  if(!provisional){
    const marker=L.circleMarker([lat,lon],{
      radius:7, weight:2, color:'#6aa0ff', fillColor:'#6aa0ff', fillOpacity:0.5
    }).bindTooltip('Your pin (click Confirm)', {direction:'top'});
    marker.addTo(map);
    provisional = {lat, lon, marker};
  }else{
    provisional.lat = lat; provisional.lon = lon;
    provisional.marker.setLatLng([lat,lon]);
  }
});

/* ========= Game flow ========= */
function startRound(){
  if(!allCities.length){ alert('Dataset not loaded yet.'); return; }
  const num=Math.max(1,Math.min(parseInt(document.getElementById('numPerRound').value||'10',10),200));
  const diffSel=[...document.querySelectorAll('input[name="difficulty"]')].find(r=>r.checked)?.value || "100000";
  let minPop = diffSel==="custom" ? parseInt(document.getElementById('customMinPop').value||'10000',10) : parseInt(diffSel,10);
  if(!Number.isFinite(minPop) || minPop<1) minPop=10000;

  const pool = allCities.filter(c => (c.pop ?? 0) >= minPop);
  if(pool.length < num){ alert(`Only ${pool.length} cities at ≥ ${minPop.toLocaleString()} pop. Reduce number per round or choose an easier level.`); return; }

  // Shuffle and pick
  const idxs=[...pool.keys()];
  for(let i=idxs.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [idxs[i],idxs[j]]=[idxs[j],idxs[i]]; }
  roundCities=idxs.slice(0,num).map(i=>pool[i]);

  // Reset round state
  clearResultLayers(); guesses=[]; currentIndex=-1; updateScoreBox();
  setTopCity(null); hideFeedbackUI(); actionMode='confirm'; confirmBtn.textContent='Confirm';
  resetMapView();

  // First city immediately
  nextCity();
}
function nextCity(){
  currentIndex++;
  actionMode='confirm'; confirmBtn.textContent='Confirm';
  hideFeedbackUI();
  resetMapView();

  if(currentIndex>=roundCities.length){
    setTopRoundSummary();
    return;
  }
  const city = roundCities[currentIndex];
  setTopCity(city);
  updateScoreBox();
}

/* ========= Confirm / Next / Results / Restart ========= */
async function confirmOrNext(){
  if(actionMode==='next'){ nextCity(); return; }
  if(actionMode==='results'){ showRoundResults(); return; }
  if(actionMode==='restart'){ startRound(); return; }
  await confirmGuess();
}
async function confirmGuess(){
  if(currentIndex<0 || currentIndex>=roundCities.length) return;
  const c=roundCities[currentIndex];
  if(!provisional){ alert('Place a pin on the map first, then press Confirm.'); return; }

  const guessLat=provisional.lat, guessLon=provisional.lon;
  const trueLat=c.lat, trueLon=c.lon;
  const dKm=haversineKm(guessLat,guessLon,trueLat,trueLon);

  // Record for results
  guesses.push({city:c,guessLat,guessLon,trueLat,trueLon,distKm:dKm});
  updateScoreBox();

  // --- FEEDBACK VIEW: draw current city's layers + zoom in + labels ---
  if(provisional.marker){ map.removeLayer(provisional.marker); }
  const guessMarker=L.circleMarker([guessLat,guessLon],{
    radius:6, weight:2, color:'#6aa0ff', fillColor:'#6aa0ff', fillOpacity:0.4
  }).bindTooltip(`Your guess<br>${fmtKm(dKm)} away`,{direction:'top'}).addTo(map);

  const trueMarker=L.circleMarker([trueLat,trueLon],{
    radius:6, weight:2, color:'#22c55e', fillColor:'#22c55e', fillOpacity:0.5
  }).bindTooltip(`${cityLabel(c)}<br>True location`,{direction:'top'}).addTo(map);

  const line=L.polyline([[guessLat,guessLon],[trueLat,trueLon]],{
    weight:2, color:'#f59e0b', opacity:.9, dashArray:'4,4'
  }).addTo(map);

  feedbackLayers.push(guessMarker,trueMarker,line);
  if(!map.hasLayer(labelsOverlay)) labelsOverlay.addTo(map);
  map.setView([trueLat,trueLon], 9, { animate:true });

  // Sidebar + title feedback
  setTopDistance(dKm);
  showFeedbackUI();
  // Fetch Wikipedia AFTER confirm, coordinate-first, and cache
  showWikipediaPanel(c);

  // Button state: Next city or See results if last
  const isLast = (currentIndex === roundCities.length - 1);
  actionMode = isLast ? 'results' : 'next';
  confirmBtn.textContent = isLast ? 'See results' : 'Next city';
}
confirmBtn.addEventListener('click', confirmOrNext);

/* ========= Results view ========= */
function showRoundResults(){
  hideFeedbackUI();
  clearFeedbackLayers(); // remove current city's overlays
  if(!map.hasLayer(labelsOverlay)) labelsOverlay.addTo(map);
  drawResultsLayers();
  fitToAllGuesses();
  setTopRoundSummary();
  actionMode = 'restart';
  confirmBtn.textContent = 'Start new round';
}

/* ========= Data loading ========= */
function normalizeHeader(h){ return (h||'').toString().replace(/^\uFEFF/,'').trim(); }
function parseAdmin1(text){
  const map = {};
  const lines = text.split(/\r?\n/);
  for(const line of lines){
    if(!line || !line.includes('\t')) continue;
    const parts = line.split('\t');
    const key = parts[0]?.trim();   // e.g., "US.CA"
    const name = parts[1]?.trim();  // "California"
    if(key && name) map[key] = name;
  }
  return map;
}
function extractSubdivision(row){
  const cc = (row['Country Code'] ?? row['Country code'] ?? row['CC'] ?? '').toString().trim();
  const a1 = (row['Admin1 Code'] ?? row['Admin1'] ?? '').toString().trim();
  if(cc && a1){
    const key = `${cc}.${a1}`;
    if(adminMap[key]) return adminMap[key];
  }
  const labelEn = row['LABEL EN'] ?? null;
  if(labelEn){
    const parts = labelEn.split(',').map(s=>s.trim()).filter(Boolean);
    if(parts.length >= 3){
      const penultimate = parts[parts.length-2];
      return penultimate || null;
    }
  }
  return null;
}
function parseRowsToCities(rows){
  const out=[];
  for(const r of rows){
    const name = (r.name ?? r.city ?? r.City ?? r.Name ?? r['ASCII Name'] ?? '').toString().trim();
    if(!name) continue;

    let pop = r.Population ?? r.population ?? r.pop ?? r['Population '];
    const popNum = parseInt(pop, 10);
    const finalPop = Number.isFinite(popNum) ? popNum : null;

    let lat = r.lat ?? r.latitude ?? r.Lat ?? r.Latitude;
    let lon = r.lon ?? r.lng ?? r.long ?? r.longitude ?? r.Lon ?? r.Longitude;
    if ((lat==null || lon==null) && (r.Coordinates!=null || r['Coordinates ']!=null)) {
      const coordStr = (r.Coordinates ?? r['Coordinates ']).toString();
      const parts = coordStr.split(',', 2);
      if (parts.length === 2) { lat = parts[0].trim(); lon = parts[1].trim(); }
    }
    const latNum = parseFloat(lat), lonNum = parseFloat(lon);
    if(!isFinite(latNum) || !isFinite(lonNum)) continue;

    const sub = extractSubdivision(r);
    const country = (r['Country name EN'] ?? '').toString().trim() || null;

    out.push({ name, lat: latNum, lon: lonNum, pop: finalPop, sub, country });
  }
  return out;
}
function loadCSV(url){
  Papa.parse(url,{
    download:true, header:true, skipEmptyLines:true, transformHeader: normalizeHeader,
    complete: function(res){
      const cities = parseRowsToCities(res.data);
      if(!cities.length){ alert('No valid rows found in geonames_10k.csv'); return; }
      allCities = cities;
      // Auto-start immediately
      startRound();
    },
    error: function(err){ console.error(err); alert('Error loading dataset.'); }
  });
}
async function boot(){
  try{
    const resp = await fetch('admin1CodesASCII.txt');
    if(resp.ok){ adminMap = parseAdmin1(await resp.text()); }
  }catch(e){ /* continue without subdivisions */ }
  loadCSV('geonames_10k.csv');
}
window.addEventListener('DOMContentLoaded', boot);

/* ========= Controls ========= */
document.getElementById('startBtn').addEventListener('click', startRound);
document.getElementById('resetBtn').addEventListener('click', ()=>{
  // Clear overlays, keep current round
  clearFeedbackLayers();
  clearResultLayers();
  if(map.hasLayer(labelsOverlay)) map.removeLayer(labelsOverlay);
  resetMapView();
});
</script>
</body>
</html>

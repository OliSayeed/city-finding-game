<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>City finding game</title>

<!-- Performance hints -->
<link rel="preconnect" href="https://en.wikipedia.org" crossorigin>
<link rel="preconnect" href="https://upload.wikimedia.org" crossorigin>

<!-- Leaflet -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""
/>
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<!-- Papa Parse -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<style>
  :root { --bg:#0b0c0f; --panel:#111317; --muted:#a9b0bd; --text:#e9eef6;
          --accent:#6aa0ff; --good:#22c55e; --mid:#f59e0b; --border:#1f2430; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
            font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial;}

  .topbar{position:fixed;z-index:1000;top:0;left:0;right:0;background:#0e1117;border-bottom:1px solid var(--border);
          display:flex;align-items:center;justify-content:space-between;padding:10px 12px;box-shadow:0 2px 12px rgba(0,0,0,.35);}
  .brand,.current-city{font-size:22px;font-weight:800;letter-spacing:.2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
  .brand{width:180px;}
  .current-city{position:absolute;left:50%;transform:translateX(-50%);text-align:center;max-width:calc(100vw - 360px);}
  .current-city .cty{color:#fff;} .current-city .sub{color:var(--muted);font-weight:600;margin-left:8px;}
  .topbar-right{width:180px;display:flex;justify-content:flex-end;}
  .btn{appearance:none;border:none;cursor:pointer;padding:10px 12px;border-radius:12px;background:#1a2233;color:#fff;
       transition:transform .02s ease,opacity .2s ease,background .2s ease;font-weight:600;letter-spacing:.2px;}
  .btn:hover{background:#1d2740;} .btn:active{transform:translateY(1px);} .btn.accent{background:var(--accent);color:#081021;}

  .app{display:grid;grid-template-columns:380px 1fr;grid-template-rows:calc(100vh - 56px);margin-top:56px;}
  .sidebar{background:var(--panel);border-right:1px solid var(--border);display:flex;flex-direction:column;}
  .section{padding:16px 18px;border-bottom:1px solid var(--border);}
  h1{font-size:18px;margin:0 0 8px;letter-spacing:.2px;}
  .muted{color:var(--muted);font-size:13px;}
  #map{height:calc(100vh - 56px);width:100%;}

  .scorebox{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;}
  .scorecard{background:#0d0f13;border:1px solid var(--border);border-radius:12px;padding:10px;text-align:center;}
  .scorecard .big{font-size:22px;font-weight:700;}

  .wiki-side{display:none;gap:10px;} .wiki-side.open{display:grid;}
  .wiki-title{font-weight:800;margin:0;font-size:22px;letter-spacing:.2px;}
  .wiki-image{width:100%;border-radius:10px;display:none;}
  .wiki-extract{font-size:13px;color:var(--muted);line-height:1.45;max-height:28vh;overflow:auto;}
  .wiki-actions{display:flex;gap:10px;} .wiki-actions a{text-decoration:none;color:var(--text);font-weight:600;}

  .controls label{display:block;font-size:13px;margin-bottom:6px;color:var(--muted);}
  .controls .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .controls input[type="number"]{width:100%;padding:10px 12px;background:#0d0f13;border:1px solid var(--border);border-radius:10px;color:#e9eef6;}
  .btnbar{display:flex;gap:8px;flex-wrap:wrap;}

  @media (max-width:1000px){
    .app{grid-template-columns:1fr;grid-template-rows:auto 70vh;}
    #map{height:calc(70vh);}
    .current-city{font-size:18px;max-width:calc(100vw - 240px);}
    .brand,.topbar-right{width:120px;}
  }
</style>
</head>
<body>

<div class="topbar">
  <div class="brand">Find the city</div>
  <div class="current-city" id="currentCityTop"></div>
  <div class="topbar-right"><button id="confirmBtn" class="btn accent">Confirm</button></div>
</div>

<div class="app">
  <aside class="sidebar">
    <div id="controlsSection" class="section controls">
      <h1>Controls</h1>
      <label>Difficulty (population threshold)</label>
      <div class="radio-group" id="difficultyGroup" style="display:grid;gap:6px;margin-top:8px;">
        <label style="display:flex;align-items:center;gap:8px;"><input type="radio" name="difficulty" value="1000000"><span>≥ 1,000,000</span></label>
        <label style="display:flex;align-items:center;gap:8px;"><input type="radio" name="difficulty" value="100000" checked><span>≥ 100,000</span></label>
        <label style="display:flex;align-items:center;gap:8px;"><input type="radio" name="difficulty" value="10000"><span>≥ 10,000</span></label>
        <label style="display:flex;align-items:center;gap:8px;">
          <input type="radio" name="difficulty" value="custom" id="diffCustom"><span>Custom ≥</span>
          <input id="customMinPop" type="number" min="1" step="1000" value="10000" style="max-width:120px;">
        </label>
      </div>
      <div class="row" style="margin-top:10px;">
        <div><label>Number per round</label><input id="numPerRound" type="number" min="1" max="200" step="1" value="10" /></div>
      </div>
      <div class="btnbar" style="margin-top:10px;">
        <button id="startBtn" class="btn accent">Start new round</button>
        <button id="resetBtn" class="btn">Clear map</button>
      </div>
    </div>

    <div id="wikiSection" class="section">
      <div id="wikiSide" class="wiki-side">
        <div class="wiki-title" id="wikiTitle"></div>
        <img id="wikiImg" class="wiki-image" alt="Place image" loading="lazy"/>
        <div class="wiki-extract" id="wikiExtract"></div>
        <div class="wiki-actions" id="wikiActions" style="display:none;">
          <a id="wikiLink" target="_blank" rel="noopener">Open on Wikipedia</a>
        </div>
      </div>
    </div>

    <div id="statusSection" class="section">
      <h1>Round status</h1>
      <div class="scorebox" style="margin-bottom:10px;">
        <div class="scorecard"><div class="muted">Guessed</div><div id="guessedCount" class="big">0</div></div>
        <div class="scorecard"><div class="muted">Remaining</div><div id="remainingCount" class="big">0</div></div>
      </div>
      <div id="summary" style="display:none;"></div>
    </div>
  </aside>

  <div id="map"></div>
</div>

<script>
/* ======= Config ======= */
const DATA_CANDIDATES = ['geonames_10k.csv', 'data/geonames_10k.csv'];
const WIKI_TIMEOUT_MS = 5000;
const PREFETCH_TIMEOUT_MS = 2200;

/* ======= Utilities ======= */
function haversineKm(lat1,lon1,lat2,lon2){
  const R=6371, toRad=d=>d*Math.PI/180;
  const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
  const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(Math.abs(dLon)/2)**2;
  return 2*R*Math.asin(Math.sqrt(a));
}
function fmtKm(km){ if(km<1) return `${(km*1000).toFixed(0)} m`; if(km<100) return `${km.toFixed(1)} km`; return `${Math.round(km)} km`; }
function stripDiacritics(s){ return s.normalize('NFD').replace(/\p{Diacritic}/gu,''); }
const WORLD_VIEW={center:[20,0],zoom:2};

/* ======= Variable-duration fly ======= */
function variableFlyTo(map, targetLat, targetLon, targetZoom){
  const cur = map.getCenter();
  const curZoom = map.getZoom();
  const distKm = haversineKm(cur.lat, cur.lng, targetLat, targetLon);

  // Tunables:
  // - speed in km/s along the great-circle (bigger => faster)
  // - additive factor for zoom delta
  // - clamp to keep durations pleasant
  const SPEED_KM_PER_S = 2500; // ~6s max for antipodal, ~1–3s typical moves
  const ZOOM_SEC_PER_LEVEL = 0.12;
  let dur = (distKm / SPEED_KM_PER_S) + (Math.abs(targetZoom - curZoom) * ZOOM_SEC_PER_LEVEL);
  dur = Math.max(0.9, Math.min(4.8, dur));

  map.flyTo([targetLat, targetLon], targetZoom, { animate:true, duration:dur, easeLinearity:0.22 });
  return dur;
}

/* ======= Map ======= */
const map=L.map('map',{minZoom:1.5,worldCopyJump:true,attributionControl:true}).setView([20,0],2);
const baseNoLabels=L.tileLayer('https://basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png',{attribution:'&copy; OpenStreetMap &copy; CARTO'}).addTo(map);
const labelsOverlay=L.tileLayer('https://basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png',{attribution:''});
map.setMaxBounds([[-85,-200],[85,200]]);

/* ======= State ======= */
let adminMap={}, allCities=[], roundCities=[], currentIndex=-1, guesses=[];
let provisional=null, actionMode='confirm';
let feedbackLayers=[], resultLayers=[];
let activeFlyToken = 0;

const currentCityTopEl=document.getElementById('currentCityTop');
const confirmBtn=document.getElementById('confirmBtn');
const controlsSection=document.getElementById('controlsSection');
const wikiSide=document.getElementById('wikiSide');
const guessedCountEl=document.getElementById('guessedCount');
const remainingCountEl=document.getElementById('remainingCount');

/* ======= Wikipedia chooser + prefetch ======= */
const wikiCache=new Map();
function cityKey(c){ return `${c.name}||${c.sub||''}||${c.country||''}`; }
function abortableFetch(url,opts={},timeoutMs=WIKI_TIMEOUT_MS){
  const c=new AbortController(); const id=setTimeout(()=>c.abort(),timeoutMs);
  return fetch(url,{...opts,signal:c.signal}).finally(()=>clearTimeout(id));
}
function mwApiT(params, timeoutMs){
  const qs=new URLSearchParams({...params,format:'json',origin:'*'});
  return abortableFetch(`https://en.wikipedia.org/w/api.php?${qs.toString()}`, {}, timeoutMs).then(r=>{
    if(!r.ok) throw new Error('Wikipedia API error'); return r.json();
  });
}
function restSummaryT(title, timeoutMs){
  const slug=encodeURIComponent(title.replace(/\s+/g,'_'));
  return abortableFetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${slug}?redirect=true`, {}, timeoutMs).then(r=>{
    if(!r.ok) throw new Error('REST summary error'); return r.json();
  });
}
const mwApi=(p)=>mwApiT(p,WIKI_TIMEOUT_MS);
const restSummary=(t)=>restSummaryT(t,WIKI_TIMEOUT_MS);

function typeScore(desc=''){
  const d=(desc||'').toLowerCase();
  if(d.includes('capital city')) return 50;
  if(d.includes('prefecture-level city')) return 46;
  if(d.includes('city')) return 45;
  if(d.includes('town')) return 40;
  if(d.includes('municipality')) return 35;
  if(d.includes('commune')) return 32;
  if(d.includes('borough')) return 28;
  if(d.includes('village')) return 20;
  if(d.includes('settlement')) return 18;
  return 0;
}
function titleScore(cityName,title){
  const n=(cityName||'').toLowerCase(), t=(title||'').toLowerCase();
  if(t===n) return 100; if(t.startsWith(n+',') || t.startsWith(n+' ')) return 90; if(t.includes(n)) return 60; return 0;
}
function distScoreKm(dKm){ return Math.max(0,30 - Math.min(30,dKm)); }
function tolKmFor(city){ const p=city.pop||0; if(p>=1_000_000) return 18; if(p>=100_000) return 12; return 8; }
function pageCoord(p){ const c=Array.isArray(p.coordinates)?p.coordinates[0]:null; return c?{lat:c.lat,lon:c.lon}:null; }
function distanceToCityKm(city,p){ const pc=pageCoord(p); return pc? haversineKm(city.lat,city.lon,pc.lat,pc.lon) : Infinity; }

async function fetchPagesInfoByTitlesT(titles, timeoutMs){
  if(!titles.length) return [];
  const info=await mwApiT({
    action:'query',
    prop:'coordinates|description|pageimages|info',
    piprop:'thumbnail',
    pithumbsize:480,
    inprop:'url',
    titles:Array.from(new Set(titles)).slice(0,40).join('|')
  }, timeoutMs);
  return Object.values(info.query?.pages || {});
}
const fetchPagesInfoByTitles=(t)=>fetchPagesInfoByTitlesT(t, WIKI_TIMEOUT_MS);

async function tryExactTitleT(city, rawTitle, timeoutMs){
  const info=await fetchPagesInfoByTitlesT([rawTitle], timeoutMs);
  const p=info[0]; if(!p) return null;
  if(distanceToCityKm(city,p)<=tolKmFor(city)) return p;
  const ascii=stripDiacritics(rawTitle);
  if(ascii && ascii!==rawTitle){
    const info2=await fetchPagesInfoByTitlesT([ascii], timeoutMs);
    const p2=info2[0]; if(p2 && distanceToCityKm(city,p2)<=tolKmFor(city)) return p2;
  }
  return null;
}
const tryExactTitle=(city,title)=>tryExactTitleT(city,title,WIKI_TIMEOUT_MS);

async function searchTitlesT(city, query, timeoutMs){
  const s=await mwApiT({action:'query',list:'search',srsearch:query,srlimit:10,srprop:''}, timeoutMs);
  const titles=(s.query?.search||[]).map(x=>x.title); if(!titles.length) return null;
  const pages=await fetchPagesInfoByTitlesT(titles, timeoutMs);
  let best=null,bestScore=-Infinity;
  for(const p of pages){
    const dKm=distanceToCityKm(city,p);
    const score=titleScore(city.name,p.title)+typeScore(p.description||'')+distScoreKm(dKm);
    if(score>bestScore){ bestScore=score; best=p; }
  }
  return best;
}
const searchTitles=(city,q)=>searchTitlesT(city,q,WIKI_TIMEOUT_MS);

async function geoSearchBest(city){
  const radii=[5000,10000,20000,30000];
  for(const r of radii){
    const geo=await mwApi({action:'query',list:'geosearch',gscoord:`${city.lat}|${city.lon}`,gsradius:r,gslimit:20,gsnamespace:0});
    const titles=(geo.query?.geosearch||[]).map(g=>g.title);
    if(!titles.length) continue;
    const pages=await fetchPagesInfoByTitles(titles);
    let best=null,bestScore=-Infinity;
    for(const p of pages){
      const dKm=distanceToCityKm(city,p);
      const score=typeScore(p.description||'')+distScoreKm(dKm)+titleScore(city.name,p.title);
      if(score>bestScore){ bestScore=score; best=p; }
    }
    if(best) return best;
  }
  return null;
}

async function chooseBestWiki(city){
  const base=city.name;
  try{ const p=await tryExactTitle(city,base); if(p) return p; }catch(e){}
  for(const t of [`${base} (city)`,`${base} (town)`,`${base} City`]){ try{ const p=await tryExactTitle(city,t); if(p) return p; }catch(e){} }
  try{ const p=await searchTitles(city,`intitle:"${base}"`); if(p && distanceToCityKm(city,p)<=30) return p; }catch(e){}
  const hints=[]; if(city.sub) hints.push(`intitle:"${base}, ${city.sub}"`);
  if(city.country) hints.push(`intitle:"${base}, ${city.country}"`,`intitle:"${base} ${city.country}"`);
  for(const q of hints){ try{ const p=await searchTitles(city,q); if(p && distanceToCityKm(city,p)<=30) return p; }catch(e){} }
  try{ const p=await geoSearchBest(city); if(p) return p; }catch(e){}
  return null;
}

/* Prefetch while user is placing pin */
async function prefetchWikipedia(city){
  const key=cityKey(city);
  if(wikiCache.has(key)) return;
  try{
    let best = await tryExactTitleT(city, city.name, PREFETCH_TIMEOUT_MS);
    if(!best) best = await searchTitlesT(city, `intitle:"${city.name}"`, PREFETCH_TIMEOUT_MS);
    if(best){
      try{
        const d = await restSummaryT(best.title, PREFETCH_TIMEOUT_MS);
        wikiCache.set(key,{
          title:d.title||best.title,
          extract:d.extract||best.description||'',
          imgSrc:d.thumbnail?.source || null,
          pageUrl:d.content_urls?.desktop?.page || best.fullurl || null
        });
      }catch(_){
        wikiCache.set(key,{
          title:best.title,
          extract:best.description||'',
          imgSrc:(best.thumbnail && best.thumbnail.source) || null,
          pageUrl:best.fullurl || null
        });
      }
    }
  }catch(_){}
}

async function showWikipediaPanel(city){
  const wikiTitle=document.getElementById('wikiTitle');
  const wikiExtract=document.getElementById('wikiExtract');
  const wikiLink=document.getElementById('wikiLink');
  const wikiActions=document.getElementById('wikiActions');
  const wikiImg=document.getElementById('wikiImg');

  wikiTitle.textContent = '';
  wikiExtract.textContent = 'Loading…';
  wikiImg.style.display='none'; wikiImg.removeAttribute('src');
  wikiActions.style.display='none';

  const key=cityKey(city);
  if(wikiCache.has(key)){
    const info=wikiCache.get(key);
    wikiTitle.textContent=info.title || '';
    wikiExtract.textContent=info.extract || 'No summary available.';
    if(info.imgSrc){ wikiImg.src=info.imgSrc; wikiImg.style.display='block'; }
    if(info.pageUrl){ wikiLink.href=info.pageUrl; wikiActions.style.display='flex'; }
    return;
  }

  try{
    const best=await chooseBestWiki(city);
    if(best){
      try{
        const d=await restSummary(best.title);
        wikiCache.set(key,{
          title:d.title||best.title,
          extract:d.extract||best.description||'No summary available.',
          imgSrc:d.thumbnail?.source || null,
          pageUrl:d.content_urls?.desktop?.page || best.fullurl || null
        });
      }catch(e){
        wikiCache.set(key,{
          title:best.title,
          extract:best.description || 'No summary available.',
          imgSrc:(best.thumbnail&&best.thumbnail.source) || null,
          pageUrl:best.fullurl || null
        });
      }
    }else{
      wikiCache.set(key,{title:'',extract:'No summary found on Wikipedia.',imgSrc:null,pageUrl:null});
    }
    const info=wikiCache.get(key);
    wikiTitle.textContent=info.title || '';
    wikiExtract.textContent=info.extract || 'No summary available.';
    if(info.imgSrc){ wikiImg.src=info.imgSrc; wikiImg.style.display='block'; }
    if(info.pageUrl){ wikiLink.href=info.pageUrl; wikiActions.style.display='flex'; }
  }catch(e){
    wikiTitle.textContent=''; wikiExtract.textContent='No summary found on Wikipedia.';
    wikiImg.style.display='none'; wikiActions.style.display='none';
  }
}

/* ======= UI helpers ======= */
function cityLabel(c){ return c.sub ? `${c.name} — ${c.sub}` : c.name; }
function setTopCity(cityObj){ currentCityTopEl.innerHTML = cityObj ? `<span class="cty">${cityObj.name}</span>${cityObj.sub?` <span class="sub">— ${cityObj.sub}</span>`:''}` : ''; }
function setTopDistance(km){ currentCityTopEl.innerHTML = `<span class="cty">${fmtKm(km)} away</span>`; }
function setTopRoundSummary(){ currentCityTopEl.innerHTML = `<span class="cty">Round summary</span>`; }
function updateScoreBox(){ guessedCountEl.textContent=guesses.length; remainingCountEl.textContent=Math.max(0, roundCities.length - guesses.length); }
function showFeedbackUI(){ controlsSection.style.display='none'; wikiSide.classList.add('open'); }
function hideFeedbackUI(){ controlsSection.style.display=''; wikiSide.classList.remove('open'); }

/* ======= Map helpers ======= */
function resetMapView(){
  if(map.hasLayer(labelsOverlay)) map.removeLayer(labelsOverlay);
  feedbackLayers.forEach(l=>map.removeLayer(l)); feedbackLayers=[];
  if(provisional && provisional.marker) map.removeLayer(provisional.marker);
  provisional=null;
  activeFlyToken++; // cancel any pending post-fly overlays
  map.setView(WORLD_VIEW.center, WORLD_VIEW.zoom, {animate:true});
}
function fitToAllGuesses(){
  const pts=[]; guesses.forEach(g=>{ pts.push([g.trueLat,g.trueLon],[g.guessLat,g.guessLon]); });
  if(pts.length){ map.fitBounds(L.latLngBounds(pts).pad(0.2)); } else { resetMapView(); }
}
function clearResultLayers(){ resultLayers.forEach(l=>map.removeLayer(l)); resultLayers=[]; }
function drawResultsLayers(){
  clearResultLayers();
  guesses.forEach(g=>{
    const gm=L.circleMarker([g.guessLat,g.guessLon],{radius:5,weight:2,color:'#6aa0ff',fillColor:'#6aa0ff',fillOpacity:0.35})
      .bindTooltip(`Your guess — ${fmtKm(g.distKm)}`,{direction:'top'}).addTo(map);
    const tm=L.circleMarker([g.trueLat,g.trueLon],{radius:5,weight:2,color:'#22c55e',fillColor:'#22c55e',fillOpacity:0.5})
      .bindTooltip(`${cityLabel(g.city)} — true`,{direction:'top'}).addTo(map);
    const ln=L.polyline([[g.guessLat,g.guessLon],[g.trueLat,g.trueLon]],{weight:2,color:'#f59e0b',opacity:.9,dashArray:'4,4'}).addTo(map);
    resultLayers.push(gm,tm,ln);
  });
}

/* ======= Provisional pin ======= */
map.on('click',(e)=>{
  if(currentIndex<0 || currentIndex>=roundCities.length) return;
  if(actionMode!=='confirm') return;
  const {lat,lng}=e.latlng;
  if(!provisional){
    const marker=L.circleMarker([lat,lng],{radius:7,weight:2,color:'#6aa0ff',fillColor:'#6aa0ff',fillOpacity:0.5})
      .bindTooltip('Your pin (click Confirm)',{direction:'top'}).addTo(map);
    provisional={lat,lon:lng,marker};
  }else{
    provisional.lat=lat; provisional.lon=lng; provisional.marker.setLatLng([lat,lng]);
  }
});

/* ======= Game flow ======= */
function startRound(){
  if(!allCities.length){ alert('Dataset not loaded yet.'); return; }
  const num=Math.max(1,Math.min(parseInt(document.getElementById('numPerRound').value||'10',10),200));
  const diffSel=[...document.querySelectorAll('input[name="difficulty"]')].find(r=>r.checked)?.value || "100000";
  let minPop = diffSel==="custom" ? parseInt(document.getElementById('customMinPop').value||'10000',10) : parseInt(diffSel,10);
  if(!Number.isFinite(minPop) || minPop<1) minPop=10000;

  const pool=allCities.filter(c=>(c.pop??0)>=minPop);
  if(pool.length<num){ alert(`Only ${pool.length} cities at ≥ ${minPop.toLocaleString()} pop. Reduce number per round or choose an easier level.`); return; }

  const idx=[...pool.keys()];
  for(let i=idx.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [idx[i],idx[j]]=[idx[j],idx[i]]; }
  roundCities=idx.slice(0,num).map(i=>pool[i]);

  clearResultLayers(); guesses=[]; currentIndex=-1; updateScoreBox();
  setTopCity(null); hideFeedbackUI(); actionMode='confirm'; confirmBtn.textContent='Confirm';
  resetMapView();
  nextCity();
}
function nextCity(){
  currentIndex++; actionMode='confirm'; confirmBtn.textContent='Confirm'; hideFeedbackUI(); resetMapView();
  if(currentIndex>=roundCities.length){ setTopRoundSummary(); return; }
  const city=roundCities[currentIndex];
  setTopCity(city); updateScoreBox();
  prefetchWikipedia(city); // silent prefetch
}

/* ======= Confirm / Next / Results / Restart ======= */
confirmBtn.addEventListener('click', async ()=>{
  if(actionMode==='next'){ nextCity(); return; }
  if(actionMode==='results'){ showRoundResults(); return; }
  if(actionMode==='restart'){ startRound(); return; }
  await confirmGuess();
});

async function confirmGuess(){
  if(currentIndex<0 || currentIndex>=roundCities.length) return;
  const c=roundCities[currentIndex];
  if(!provisional){ alert('Place a pin on the map first, then press Confirm.'); return; }

  const guessLat=provisional.lat, guessLon=provisional.lon;
  const trueLat=c.lat, trueLon=c.lon;
  const dKm=haversineKm(guessLat,guessLon,trueLat,trueLon);

  guesses.push({city:c,guessLat,guessLon,trueLat,trueLon,distKm:dKm}); updateScoreBox();

  // Remove provisional pin immediately
  if(provisional?.marker) { map.removeLayer(provisional.marker); }
  provisional=null;

  // Start feedback UI + load wiki
  setTopDistance(dKm);
  showFeedbackUI();
  showWikipediaPanel(c);

  // Turn on labels immediately (start of the fly)
  if(!map.hasLayer(labelsOverlay)) labelsOverlay.addTo(map);

  // Token to avoid overlay drop after interrupt
  const myToken = ++activeFlyToken;

  // After fly finishes, add markers/line so they don't scale during zoom
  const onFlyEnd = ()=>{
    if(myToken !== activeFlyToken) return;
    const gm=L.circleMarker([guessLat,guessLon],{radius:6,weight:2,color:'#6aa0ff',fillColor:'#6aa0ff',fillOpacity:0.4})
      .bindTooltip(`Your guess<br>${fmtKm(dKm)} away`,{direction:'top'}).addTo(map);
    const tm=L.circleMarker([trueLat,trueLon],{radius:6,weight:2,color:'#22c55e',fillColor:'#22c55e',fillOpacity:0.5})
      .bindTooltip(`${cityLabel(c)}<br>True location`,{direction:'top'}).addTo(map);
    const ln=L.polyline([[guessLat,guessLon],[trueLat,trueLon]],{weight:2,color:'#f59e0b',opacity:.9,dashArray:'4,4'}).addTo(map);
    feedbackLayers.push(gm,tm,ln);
  };
  const onceHandler = ()=>{ map.off('moveend', onceHandler); onFlyEnd(); };
  map.on('moveend', onceHandler);

  // Variable-duration camera based on distance + zoom delta
  variableFlyTo(map, trueLat, trueLon, 9);

  const isLast=(currentIndex===roundCities.length-1);
  actionMode=isLast?'results':'next';
  confirmBtn.textContent=isLast?'See results':'Next city';
}

/* ======= Results ======= */
function showRoundResults(){
  hideFeedbackUI();
  activeFlyToken++; // cancel any pending overlay drops
  feedbackLayers.forEach(l=>map.removeLayer(l)); feedbackLayers=[];
  if(!map.hasLayer(labelsOverlay)) labelsOverlay.addTo(map);
  drawResultsLayers();
  fitToAllGuesses();
  setTopRoundSummary();
  actionMode='restart';
  confirmBtn.textContent='Start new round';
}

/* ======= Data loading (robust) ======= */
function normalizeHeader(h){ return (h||'').toString().replace(/^\uFEFF/,'').trim(); }
function looksLikeHTML(text){ return /^\s*<!doctype html>|^\s*<html/i.test(text); }
function parseAdmin1(text){
  const map={}; text.split(/\r?\n/).forEach(line=>{
    if(!line || !line.includes('\t')) return;
    const [key,name]=line.split('\t'); if(key && name) map[key.trim()]=name.trim();
  }); return map;
}
function extractSubdivision(row){
  const cc = (row['Country Code'] ?? row['Country code'] ?? row['CC'] ?? '').toString().trim();
  const a1 = (row['Admin1 Code'] ?? row['Admin1'] ?? '').toString().trim();
  if(cc && a1){
    const key = `${cc}.${a1}`;
    if(adminMap[key]) return adminMap[key];
  }
  const labelEn = row['LABEL EN'] ?? null;
  if(labelEn){
    const parts = labelEn.split(',').map(s=>s.trim()).filter(Boolean);
    if(parts.length >= 3){
      const penultimate = parts[parts.length-2];
      return penultimate || null;
    }
  }
  return null;
}
function parseRowsToCities(rows){
  const out=[];
  for(const r of rows){
    const keys = Object.keys(r);
    if(!keys.length) continue;

    const lower = {}; for(const k of keys){ lower[normalizeHeader(k).toLowerCase()] = k; }

    const name = (r[lower['name']] ?? r[lower['ascii name']] ?? r[lower['city']] ?? r[lower['placename']] ?? '').toString().trim();
    if(!name) continue;

    let latRaw = r[lower['lat']] ?? r[lower['latitude']] ?? r[lower['lat (deg)']] ?? r[lower['y']];
    let lonRaw = r[lower['lon']] ?? r[lower['long']] ?? r[lower['lng']] ?? r[lower['longitude']] ?? r[lower['x']];

    if((latRaw==null || lonRaw==null) && (r['Coordinates']!=null || r['Coordinates ']!=null)){
      const coordStr = (r['Coordinates'] ?? r['Coordinates '']).toString();
      const parts = coordStr.split(',',2); if(parts.length===2){ latRaw=parts[0].trim(); lonRaw=parts[1].trim(); }
    }

    const lat = parseFloat(String(latRaw).replace(',','.'));
    const lon = parseFloat(String(lonRaw).replace(',','.'));
    if(!isFinite(lat) || !isFinite(lon)) continue;
    if(lat<-90 || lat>90 || lon<-180 || lon>180) continue;

    const popRaw = r['Population'] ?? r['population'] ?? r['pop'] ?? r['Population '] ?? r['POP'] ?? null;
    const pop = Number.isFinite(parseInt(popRaw,10)) ? parseInt(popRaw,10) : null;

    const sub = extractSubdivision(r);
    const country = (r['Country name EN'] ?? r['Country'] ?? r['Country Name'] ?? r['country'] ?? '').toString().trim() || null;

    out.push({ name, lat, lon, pop, sub, country });
  }
  return out;
}

function tryParseCSV(url, resolve, reject){
  Papa.parse(url,{
    download:true, header:true, skipEmptyLines:true, transformHeader: normalizeHeader,
    complete: function(res){
      try{
        const fields = res.meta?.fields || [];
        if(!fields.length){
          fetch(url).then(r=>r.text()).then(t=>{
            if(looksLikeHTML(t)){ reject(new Error(`Fetched HTML instead of CSV from "${url}". Is the file path correct?`)); }
            else reject(new Error(`No header row detected in "${url}".`));
          }).catch(()=>reject(new Error(`Could not load "${url}".`)));
          return;
        }

        console.log('[CSV] Detected headers:', fields);
        if(res.data && res.data.length) console.log('[CSV] Sample row:', res.data[0]);

        const cities = parseRowsToCities(res.data);
        if(!cities.length){
          reject(new Error(`No valid rows found in "${url}". Check that it’s a real CSV with name/lat/lon columns.`));
          return;
        }
        resolve(cities);
      }catch(err){
        reject(err);
      }
    },
    error: function(err){ reject(err); }
  });
}
async function loadCSVWithFallbacks(){
  let lastErr=null;
  for(const url of DATA_CANDIDATES){
    try{
      const cities = await new Promise((resolve,reject)=>tryParseCSV(url, resolve, reject));
      return {url, cities};
    }catch(e){
      console.warn(`[CSV] Failed "${url}":`, e);
      lastErr=e;
    }
  }
  throw lastErr || new Error('Failed to load any CSV candidate.');
}
async function loadAdmin(){
  try{
    const resp = await fetch('admin1CodesASCII.txt');
    if(resp.ok){ adminMap = parseAdmin1(await resp.text()); }
  }catch(e){ console.warn('Admin1 not loaded (ok):', e); }
}

/* ======= Boot ======= */
async function boot(){
  await loadAdmin();
  try{
    const {url, cities} = await loadCSVWithFallbacks();
    console.log(`[CSV] Loaded from: ${url} — ${cities.length} cities`);
    allCities = cities;
    startRound(); // auto-start
  }catch(e){
    console.error(e);
    alert(e.message + '\n\nTips:\n• Ensure geonames_10k.csv is at the site root (or in /data/).\n• If using GitHub Pages, confirm the exact path and that the file is actually being served as CSV (not a 404 HTML).');
  }
}
window.addEventListener('DOMContentLoaded', boot);

/* ======= Controls ======= */
document.getElementById('startBtn').addEventListener('click', startRound);
document.getElementById('resetBtn').addEventListener('click', ()=>{
  feedbackLayers.forEach(l=>map.removeLayer(l)); feedbackLayers=[];
  clearResultLayers();
  if(map.hasLayer(labelsOverlay)) map.removeLayer(labelsOverlay);
  resetMapView();
});
</script>
</body>
</html>
